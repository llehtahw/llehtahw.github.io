偶尔会想一想，programming language 和 runtime 之间的关系。

以动态内存管理在c和c++的区别与连系为例。c语言本身没有动态内存管理，需要依赖标准库函数`malloc`。而c++语言，表面上可以认为动态内存是个语言特性（区别于 runtime，但一定程度上也依赖 runtime），需要一个新的空间或者对象，可以用关键字`new`来搞定，不需要像c语言那样引入奇怪的头文件。

相比更多别的更高级各有特色的语言，比如 python、ruby、nim、rust，c++ 的 build system （野生CMake，野生Bazel）和 package management（野生Conan）是有些阻碍工作的，各个库对STL的态度又各不相同，以至于最稳妥的跨库调用还只能指望裸指针而不是靠对象。

前两天遇到的问题直接让我裂开了，我感觉瞬间不想用c++，甚至感觉白学了。概括来说就是，一个库里new创建的对象，在另一个库里delete，会崩。排查除问题后发现不仅是对象，就是一个int这么操作都出了问题。

类似c++ ABI，这种问题是debug起来并没有价值的，但很费劲。大致的情况是，`a.dll`中[替换了`operator new`和`operator delete`](https://en.cppreference.com/w/cpp/memory/new/operator_new)，而`b.dll`中没有替换（或替换的实现不一致），那么`a.dll`中使用 new 创建的对象在`b.dll`中 delete 释放空间时就可能出问题，因为 new delete 不匹配。至于这个全局替换为啥只在 a 而不在 b 中生效，实在没有心情再细看了。

有一个还算公认的好习惯，就是不要用裸指针，应该用对象封装指针，至少也该用STL。智能指针中，`unique_ptr`用它的第二个模板参数来指定指针的释放方法，默认是 delete 指针；`shared_ptr` 可以在构造、reset 的时候给一个释放函数，默认也是 delete。主要区别在于，前者在 `unique_ptr<T, Deleter>` 类型确定时，释放函数就确定了，而后者的释放函数可以保留在 `shared_ptr<T>` 这个对象实例中。

结合前面所说，如果在接口中使用了`unique_ptr<T>`来传递指针（第二个模板参数保持默认），那么两个库中释放空间的逻辑可能不一样，从而导致 error。这意味着我们反而就不该使用`unique_ptr`来跨库传递指针，反而是`shared_ptr`显得安全，但也要注意用法才能保证安全。

再分析一下别的STL，`vector`、`list`、`map` 等容器都是在类型中指定了 `allocator` 的，如果保持默认，那么根据 `std::allocator` 实现的不同，这有可能出问题，也可能不出问题，谨慎一点，按照出问题来进行假设吧。

避免使用STL的库在某种程度上对这类问题有一定的抵抗能力，当与之相对的，在跨库调用方面就更难用一些，最后最可靠的居然是全部可靠的跨库调用都是c封装的接口。

标准库也是编程语言的很重要的一部分，每一版 c++ 标准都伴随着大量标准库的变化。而标准库应当是可靠的，使用同一个标准库，仅仅是所在环境不一样就导致了行为不一样，我认为这样的风险是一个语言不能接受的。即便不谈标准库，今天提到的这个问题，仅仅使用关键字 `new` 和 `delete` 就可以触发。在我看来，直接不允许开发者替换 `void* operator new(size_t)` 函数基本上就可以避免这个问题了。

---

所以 language 和 runtime 很大程度上是无法分离的，这个问题本质上也是基于经典的符号查找的 runtime 产生，而汇编、c语言都很依赖这一套。不止如此，还有全局初始函数、thread local 变量、calling convention等等等等一系列底层 api 问题都或多或少有坑，想要更轻松屏蔽这些问题，最好的还是单独建立一套运行模型，比如 java 虚拟机、JavaScript 解释器之类的。

但是不 native 感觉还是不够过瘾，没啥办法，c++ 接着用吧，不然试试 rust？